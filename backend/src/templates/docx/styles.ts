// DOCX Styles and Configuration
import {
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType,
  PageBreak,
  convertInchesToTwip,
  TableOfContents,
  StyleLevel,
  BorderStyle,
} from 'docx';

// Document metadata
export const getDocumentProperties = (title: string, workflowType: string) => ({
  creator: 'IIoT Account Intelligence',
  title,
  subject: formatWorkflowType(workflowType),
  keywords: 'account intelligence, analysis, cisco, meraki, report',
  description: `${formatWorkflowType(workflowType)} generated by IIoT Account Intelligence`,
});

// Page setup
export const pageSettings = {
  page: {
    size: {
      width: convertInchesToTwip(8.5),
      height: convertInchesToTwip(11),
    },
    margin: {
      top: convertInchesToTwip(1),
      bottom: convertInchesToTwip(1),
      left: convertInchesToTwip(1.25),
      right: convertInchesToTwip(1.25),
    },
  },
};

// Custom styles
export const documentStyles = {
  paragraphStyles: [
    {
      id: 'Normal',
      name: 'Normal',
      basedOn: 'Normal',
      quickFormat: true,
      run: {
        size: 22, // 11pt
        font: 'Calibri',
        color: '1F2937',
      },
      paragraph: {
        spacing: { after: 240, line: 276 }, // ~1.15 line spacing
      },
    },
    {
      id: 'Title',
      name: 'Title',
      basedOn: 'Normal',
      quickFormat: true,
      run: {
        size: 72, // 36pt
        bold: true,
        font: 'Calibri',
        color: '111827',
      },
      paragraph: {
        spacing: { after: 480 },
        alignment: AlignmentType.CENTER,
      },
    },
    {
      id: 'Heading1',
      name: 'Heading 1',
      basedOn: 'Normal',
      next: 'Normal',
      quickFormat: true,
      run: {
        size: 36, // 18pt
        bold: true,
        font: 'Calibri',
        color: '049FD9',
      },
      paragraph: {
        spacing: { before: 480, after: 240 },
        border: {
          bottom: {
            color: '049FD9',
            size: 12,
            style: BorderStyle.SINGLE,
            space: 4,
          },
        },
      },
    },
    {
      id: 'Heading2',
      name: 'Heading 2',
      basedOn: 'Normal',
      next: 'Normal',
      quickFormat: true,
      run: {
        size: 28, // 14pt
        bold: true,
        font: 'Calibri',
        color: '1F2937',
      },
      paragraph: {
        spacing: { before: 360, after: 180 },
      },
    },
    {
      id: 'Heading3',
      name: 'Heading 3',
      basedOn: 'Normal',
      next: 'Normal',
      quickFormat: true,
      run: {
        size: 24, // 12pt
        bold: true,
        font: 'Calibri',
        color: '374151',
      },
      paragraph: {
        spacing: { before: 280, after: 140 },
      },
    },
    {
      id: 'Subtitle',
      name: 'Subtitle',
      basedOn: 'Normal',
      quickFormat: true,
      run: {
        size: 36, // 18pt
        font: 'Calibri',
        color: '049FD9',
      },
      paragraph: {
        spacing: { after: 960 },
        alignment: AlignmentType.CENTER,
      },
    },
    {
      id: 'Quote',
      name: 'Quote',
      basedOn: 'Normal',
      run: {
        italics: true,
        color: '4B5563',
      },
      paragraph: {
        indent: { left: convertInchesToTwip(0.5) },
      },
    },
    {
      id: 'ListBullet',
      name: 'List Bullet',
      basedOn: 'Normal',
      paragraph: {
        spacing: { after: 120 },
        bullet: {
          level: 0,
        },
      },
    },
  ],
};

// Helper function
export const formatWorkflowType = (workflowType: string): string => {
  switch (workflowType) {
    case 'ACCOUNT_INTELLIGENCE':
      return 'Account Intelligence Report';
    case 'COMPETITIVE_INTELLIGENCE':
      return 'Competitive Intelligence Report';
    case 'NEWS_DIGEST':
      return 'News Digest';
    default:
      return workflowType.replace(/_/g, ' ');
  }
};

export const formatSectionName = (sectionKey: string): string => {
  return sectionKey
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
};

export const formatDate = (date: Date): string => {
  return new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  }).format(date);
};

// Create cover page paragraphs
export const createCoverPage = (data: {
  title: string;
  companyName: string;
  workflowType: string;
  generatedAt: Date;
  reportId: string;
}): Paragraph[] => {
  return [
    // Spacer
    new Paragraph({
      children: [new TextRun({ text: '' })],
      spacing: { before: 6000 },
    }),
    // Workflow type badge
    new Paragraph({
      children: [
        new TextRun({
          text: formatWorkflowType(data.workflowType).toUpperCase(),
          size: 20, // 10pt
          color: '6B7280',
          allCaps: true,
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 480 },
    }),
    // Title
    new Paragraph({
      children: [
        new TextRun({
          text: data.title,
          size: 72, // 36pt
          bold: true,
          color: '111827',
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 240 },
    }),
    // Company name
    new Paragraph({
      children: [
        new TextRun({
          text: data.companyName || '',
          size: 36, // 18pt
          color: '049FD9',
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 6000 },
    }),
    // Generated date
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated: ${formatDate(data.generatedAt)}`,
          size: 20, // 10pt
          color: '6B7280',
        }),
      ],
      alignment: AlignmentType.CENTER,
    }),
    // Report ID
    new Paragraph({
      children: [
        new TextRun({
          text: `Report ID: ${data.reportId}`,
          size: 18, // 9pt
          color: '9CA3AF',
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 240 },
    }),
    // Page break
    new Paragraph({
      children: [new PageBreak()],
    }),
  ];
};

// Create table of contents
export const createTableOfContents = (): (Paragraph | TableOfContents)[] => {
  return [
    new Paragraph({
      children: [
        new TextRun({
          text: 'Table of Contents',
          size: 48, // 24pt
          bold: true,
          color: '111827',
        }),
      ],
      spacing: { after: 480 },
      border: {
        bottom: {
          color: '049FD9',
          size: 18,
          style: BorderStyle.SINGLE,
          space: 8,
        },
      },
    }),
    new TableOfContents('Table of Contents', {
      hyperlink: true,
      headingStyleRange: '1-3',
      stylesWithLevels: [
        new StyleLevel('Heading1', 1),
        new StyleLevel('Heading2', 2),
        new StyleLevel('Heading3', 3),
      ],
    }),
    new Paragraph({
      children: [new PageBreak()],
    }),
  ];
};

// Parse markdown content into paragraphs
export const parseMarkdownToDocx = (content: string): Paragraph[] => {
  const paragraphs: Paragraph[] = [];
  const lines = content.split('\n');

  let inList = false;
  let listItems: string[] = [];

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines
    if (!trimmed) {
      if (inList && listItems.length > 0) {
        // End list
        listItems.forEach((item) => {
          paragraphs.push(
            new Paragraph({
              children: [new TextRun({ text: item, size: 22 })],
              bullet: { level: 0 },
              spacing: { after: 120 },
            })
          );
        });
        listItems = [];
        inList = false;
      }
      continue;
    }

    // Headers
    if (trimmed.startsWith('### ')) {
      paragraphs.push(
        new Paragraph({
          text: trimmed.replace('### ', ''),
          heading: HeadingLevel.HEADING_3,
        })
      );
    } else if (trimmed.startsWith('## ')) {
      paragraphs.push(
        new Paragraph({
          text: trimmed.replace('## ', ''),
          heading: HeadingLevel.HEADING_2,
        })
      );
    } else if (trimmed.startsWith('# ')) {
      paragraphs.push(
        new Paragraph({
          text: trimmed.replace('# ', ''),
          heading: HeadingLevel.HEADING_1,
        })
      );
    }
    // Lists
    else if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
      inList = true;
      listItems.push(trimmed.replace(/^[-*]\s+/, ''));
    } else if (/^\d+\.\s/.test(trimmed)) {
      inList = true;
      listItems.push(trimmed.replace(/^\d+\.\s+/, ''));
    }
    // Blockquote
    else if (trimmed.startsWith('> ')) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmed.replace('> ', ''),
              italics: true,
              color: '4B5563',
              size: 22,
            }),
          ],
          indent: { left: convertInchesToTwip(0.5) },
          spacing: { after: 240 },
        })
      );
    }
    // Regular paragraph
    else {
      // Process inline formatting
      const runs = processInlineFormatting(trimmed);
      paragraphs.push(
        new Paragraph({
          children: runs,
          spacing: { after: 240 },
        })
      );
    }
  }

  // Handle any remaining list items
  if (listItems.length > 0) {
    listItems.forEach((item) => {
      paragraphs.push(
        new Paragraph({
          children: [new TextRun({ text: item, size: 22 })],
          bullet: { level: 0 },
          spacing: { after: 120 },
        })
      );
    });
  }

  return paragraphs;
};

// Process inline markdown formatting (bold, italic)
const processInlineFormatting = (text: string): TextRun[] => {
  const runs: TextRun[] = [];

  // Simple regex-based parsing for bold and italic
  // This is a simplified version - production would need more robust parsing
  const parts = text.split(/(\*\*[^*]+\*\*|\*[^*]+\*|__[^_]+__|_[^_]+_)/);

  for (const part of parts) {
    if (!part) continue;

    if (part.startsWith('**') && part.endsWith('**')) {
      runs.push(
        new TextRun({
          text: part.slice(2, -2),
          bold: true,
          size: 22,
        })
      );
    } else if (part.startsWith('__') && part.endsWith('__')) {
      runs.push(
        new TextRun({
          text: part.slice(2, -2),
          bold: true,
          size: 22,
        })
      );
    } else if (part.startsWith('*') && part.endsWith('*')) {
      runs.push(
        new TextRun({
          text: part.slice(1, -1),
          italics: true,
          size: 22,
        })
      );
    } else if (part.startsWith('_') && part.endsWith('_')) {
      runs.push(
        new TextRun({
          text: part.slice(1, -1),
          italics: true,
          size: 22,
        })
      );
    } else {
      runs.push(
        new TextRun({
          text: part,
          size: 22,
        })
      );
    }
  }

  return runs.length > 0 ? runs : [new TextRun({ text, size: 22 })];
};
